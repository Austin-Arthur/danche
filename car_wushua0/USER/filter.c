/*
 * filter.c
 *
 *  Created on: 2022年2月21日
 *      Author: 11609
 */
#include "filter.h"
  /**************************************************************************
二维卡尔曼滤波
调试经验： Q越小越相信模型预测值
       R越小越相信传感器测量值
优势：可调性强
劣势：整定需经验，没有有较高需求时先考虑互补
**************************************************************************/

float angle,angle_dot;
float Q_angle=0.03;//0.015 过程噪声的协方差
float Q_gyro=0.01;//0.02 过程噪声的协方差 过程噪声的协方差为一个一行两列矩阵
float R_angle=0.05;//0.003 测量噪声的协方差 既测量偏差
float dt=0.005;//
char  C_0 = 1;
float Q_bias, Angle_err;
float PCt_0, PCt_1, E;
float K_0, K_1, t_0, t_1;
float Pdot[4] ={0,0,0,0};
float PP[2][2] = { { 1, 0 },{ 0, 1 } };

/**************************************************************************
函数功能：简易卡尔曼滤波
入口参数：加速度、角速度
返回  值：无
**************************************************************************/
void Kalman_Filter(float Accel,float Gyro)
{
    angle+=(Gyro - Q_bias) * dt; //先验估计
    Pdot[0]=Q_angle - PP[0][1] - PP[1][0]; // Pk-先验估计误差协方差的微分

    Pdot[1]=-PP[1][1];
    Pdot[2]=-PP[1][1];
    Pdot[3]=Q_gyro;
    PP[0][0] += Pdot[0] * dt;   // Pk-先验估计误差协方差微分的积分
    PP[0][1] += Pdot[1] * dt;   // =先验估计误差协方差
    PP[1][0] += Pdot[2] * dt;
    PP[1][1] += Pdot[3] * dt;

    Angle_err = Accel - angle;  //zk-先验估计

    PCt_0 = C_0 * PP[0][0];
    PCt_1 = C_0 * PP[1][0];

    E = R_angle + C_0 * PCt_0;

    K_0 = PCt_0 / E;
    K_1 = PCt_1 / E;

    t_0 = PCt_0;
    t_1 = C_0 * PP[0][1];

    PP[0][0] -= K_0 * t_0;       //后验估计误差协方差
    PP[0][1] -= K_0 * t_1;
    PP[1][0] -= K_1 * t_0;
    PP[1][1] -= K_1 * t_1;

    angle   += K_0 * Angle_err;  //后验估计
    Q_bias  += K_1 * Angle_err;  //后验估计
    angle_dot   = Gyro - Q_bias;     //输出值(后验估计)的微分=角速度

    angle_klm_roll = angle;

}
/**************************************************************************
函数功能：一唯简易卡尔曼滤波
入口参数：单变量
返回  值：无
**************************************************************************/
double KalmanFilter(Kalman_Typedef *klm, double input)
{
    //预测协方差方程：k时刻系统估算协方差 = k-1时刻的系统协方差 + 过程噪声协方差
    klm->Now_P = klm->LastP + klm->Q;
    //卡尔曼增益方程：卡尔曼增益 = k时刻系统估算协方差 / （k时刻系统估算协方差 + 观测噪声协方差）
    klm->Kg = klm->Now_P / (klm->Now_P + klm->R);
    //更新最优值方程：k时刻状态变量的最优值 = 状态变量的预测值 + 卡尔曼增益 * （测量值 - 状态变量的预测值）
    klm->out = klm->out + klm->Kg * (input -klm->out);//因为这一次的预测值就是上一次的输出值
    //更新协方差方程: 本次的系统协方差赋给 klm->LastP 为下一次运算准备。
    klm->LastP = (1-klm->Kg) * klm->Now_P;

    return (klm->out);
}

void Kalman_Init(Kalman_Typedef *klm, const double klm_Q, const double klm_R)//温度klm_Q=0.01 klm_R=0.25
{
    klm->LastP=0.02;        //上次估算协方差
    klm->Now_P=0;           //当前估算协方差
    klm->out=0;             //卡尔曼滤波器输出
    klm->Kg=0;              //卡尔曼增益
    klm->Q=klm_Q;           //Q:过程噪声协方差 Q参数调滤波后的曲线平滑程度，Q越小越平滑;
    klm->R=klm_R;           //R:观测噪声协方差 R参数调整滤波后的曲线与实测曲线的相近程度，R越小越接近(收敛越快)
}


/**************************************************************************
函数功能：低通滤波
入口参数：滤波量，截止频率
返回  值：滤波后值
滤波后结果存在静态温差
**************************************************************************/
float lpf(float thr,float fc)
{
    float thr_lpf;
    int T = 5;//5ms中断滤波
    thr_lpf+=(1 / (1 + 1/(2.0f * 3.14f * T * fc )))*(thr - thr_lpf);
    return thr_lpf;
}


